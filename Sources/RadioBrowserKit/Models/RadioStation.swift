//
//  Station.swift
//  RadioBrowserKit
//
//  Created by Azamah Junior Khan on 27/05/2025.
//

import Foundation

public struct RadioStation: Codable, Hashable {
    
    /// A globally unique identifier for the change of the station information
    public let changeUuid: String
    
    /// A globally unique identifier for the station
    public let stationUuid: String
    
    /// The stations name
    public let name: String
    
    /// The stream URL provided by the use
    /// Possible value/data types: string, URL (HTTP/HTTPS)
    public let url: String
    
    /// An automatically "resolved" stream URL. Things resolved are playlists (M3U/PLS/ASX...), HTTP redirects (Code 301/302). This link is especially useful if you use this API from a platform that is not able to do a resolve on its own (e.g. JavaScript in browser) or you just don't want to invest the time in decoding playlists yourself.
    /// Possible value/data types: string, URL (HTTP/HTTPS)
    public let urlResolved: String
    
    /// URL to the homepage of the stream, so you can direct the user to a page with more information about the stream
    /// Possible value/data types: string, URL (HTTP/HTTPS)
    public let homepage: String
    
    /// URL to an icon or picture that represents the stream. (PNG, JPG)
    /// Possible value/data types: string, URL (HTTP/HTTPS)
    public let favicon: String
    
    /// Tags of the stream with more information about it
    /// Possible value/data types: string, multivalue, split by comma
    public let tags: String
    
    /// Full name of the country. Currently it is autogenerated from the `countryCode`
    ///
    /// - Warning: This property has been deprecated
    @available(*, deprecated, message: "Use `countryCode` instead")
    public let country: String
    
    /// Official country codes as in  `ISO 3166-1 alpha-2`
    /// Possible value/data types: 2 letters, uppercase
    public let countryCode: String
    
    /// The ISO-3166-2 code of the entity where the station is located inside the country
    public let iso31662: String
    
    /// Full name of the state where the station is located inside the country
    public let state: String
    
    /// Languages that are spoken in this stream
    /// Possible value/data types: string, multivalue, split by comma
    public let language: String
    
    /// Languages that are spoken in this stream by code ISO 639-2/B
    /// Possible value/data types: string, multivalue, split by comma
    public let languageCodes: String
    
    /// Number of votes for this station. This number is by server and only ever increases. It will never be reset to 0.
    public let votes: Int
    
    /// Last time when the stream information was changed in the database
    /// Possible value/data types: datetime, YYYY-MM-DD HH:mm:ss
    public let lastChangeTime: String
    
    /// Last time when the stream information was changed in the database
    /// Possible value/data types: datetime, ISO 8601
    public let lastChangeTimeIso8601: String
    
    /// The codec of this stream recorded at the last check.
    public let codec: String
    
    /// The bitrate of this stream recorded at the last check.
    public let bitrate: Int
    
    /// Mark if this stream is using HLS distribution or non-HLS
    public let hls: Int
    
    /// The current online/offline state of this stream. This is a value calculated from multiple measure points in the internet. The test servers are located in different countries. It is a majority vote.
    public let lastCheckOk: Int
    
    /// The last time when any radio-browser server checked the online state of this stream
    /// Possible value/data types: datetime, YYYY-MM-DD HH:mm:ss
    public let lastCheckTime: String
    
    /// The last time when any radio-browser server checked the online state of this stream
    /// Possible value/data types: datetime, ISO 8601
    public let lastCheckTimeIso8601: String
    
    /// The last time when any radio-browser server checked the online state of this stream
    /// Possible value/data types: datetime, ISO 8601
    public let lastCheckOkTime: String
    
    /// The last time when any radio-browser server checked the online state of this stream
    /// Possible value/data types: datetime, ISO 8601
    public let lastCheckOkTimeIso8601: String
    
    /// The last time when this server checked the online state and the metadata of this stream
    /// Possible value/data types: datetime, ISO 8601
    public let lastLocalCheckTime: String
    
    /// The last time when this server checked the online state and the metadata of this stream
    /// Possible value/data types: datetime, ISO 8601
    public let lastLocalCheckTimeIso8601: String
    
    /// The time of the last click recorded for this stream
    public let clickTimeStamp: String
    
    /// The time of the last click recorded for this stream
    /// Possible value/data types: datetime, ISO 8601
    public let clickTimeStampIso8601: String
    
    /// Clicks within the last 24 hours
    public let clickCount: Int
    
    /// The difference of the click counts within the last 2 days. Positive values mean an increase, negative a decrease of clicks.
    public let clickTrend: Int
    
    ///  0 means no error, 1 means that there was an ssl error while connecting to the stream url.
    public let sslError: Int
    
    /// Latitude on earth where the stream is located.
    public let geoLat: Double
    
    /// Longitude on earth where the stream is located.
    public let geoLong: Double
    
    /// Distance of the station in meters. ONLY set if geo_lat AND geo_long are set on the station AND on the request.
    public let geoDistance: Double
    
    /// Is true, if the stream owner does provide extended information as HTTP headers which override the information in the database.
    public let hasExtendedInfo: Bool
    
    // Custom CodingKeys to map between Swift property names and JSON keys
    enum CodingKeys: String, CodingKey {
        case changeUuid = "changeuuid"
        case stationUuid = "stationuuid"
        case name
        case url
        case urlResolved = "url_resolved"
        case homepage
        case favicon
        case tags
        case country
        case countryCode = "countrycode"
        case iso31662 = "iso_3166_2"
        case state
        case language
        case languageCodes = "languagecodes"
        case votes
        case lastChangeTime = "lastchangetime"
        case lastChangeTimeIso8601 = "lastchangetime_iso8601"
        case codec
        case bitrate
        case hls
        case lastCheckOk = "lastcheckok"
        case lastCheckTime = "lastchecktime"
        case lastCheckTimeIso8601 = "lastchecktime_iso8601"
        case lastCheckOkTime = "lastcheckoktime"
        case lastCheckOkTimeIso8601 = "lastcheckoktime_iso8601"
        case lastLocalCheckTime = "lastlocalchecktime"
        case lastLocalCheckTimeIso8601 = "lastlocalchecktime_iso8601"
        case clickTimeStamp = "clicktimestamp"
        case clickTimeStampIso8601 = "clicktimestamp_iso8601"
        case clickCount = "clickcount"
        case clickTrend = "clicktrend"
        case sslError = "ssl_error"
        case geoLat = "geo_lat"
        case geoLong = "geo_long"
        case geoDistance = "geo_distance"
        case hasExtendedInfo = "has_extended_info"
    }
}

// MARK: - Convenience Extensions
extension RadioStation {
    /// Returns tags as an array of strings
    var tagsArray: [String] {
        return tags.components(separatedBy: ",").map { $0.trimmingCharacters(in: .whitespaces) }
    }
    
    /// Returns languages as an array of strings
    var languagesArray: [String] {
        return language.components(separatedBy: ",").map { $0.trimmingCharacters(in: .whitespaces) }
    }
    
    /// Returns language codes as an array of strings
    var languageCodesArray: [String] {
        return languageCodes.components(separatedBy: ",").map { $0.trimmingCharacters(in: .whitespaces) }
    }
    
    /// Returns true if the station is currently working (last check was OK)
    var isWorking: Bool {
        return lastCheckOk == 1
    }
    
    /// Returns true if the station uses SSL
    var hasSSLError: Bool {
        return sslError != 0
    }
    
    /// Returns true if the station supports HLS streaming
    var supportsHLS: Bool {
        return hls == 1
    }
}
